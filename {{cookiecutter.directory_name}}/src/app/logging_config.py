import atexit
import datetime as dt
import json
import logging
import logging.config
import logging.handlers
import os
import pathlib
from typing import override

LOGS_DIR = "logs"

LOG_RECORD_BUILTIN_ATTRS = {
    "args",
    "asctime",
    "created",
    "exc_info",
    "exc_text",
    "extra",
    "filename",
    "funcName",
    "levelname",
    "levelno",
    "lineno",
    "module",
    "msecs",
    "message",
    "msg",
    "name",
    "pathname",
    "process",
    "processName",
    "relativeCreated",
    "stack_info",
    "thread",
    "threadName",
    "taskName",
}


class MyJSONFormatter(logging.Formatter):
    """Custom JSON formatter for logging.

    This formatter converts log records to JSON format, allowing for
    structured logging. It can include custom fields specified by the
    user through the `fmt_keys` parameter.

    Args:
        fmt_keys (dict[str, str], optional): A dictionary mapping
            custom field names to log record attributes. Defaults to None.

    Returns:
        str: A JSON string representation of the log record.

    Raises:
        ValueError: If the provided fmt_keys are invalid.
    """

    def __init__(
        self,
        *,
        fmt_keys: dict[str, str] | None = None,
    ):
        super().__init__()
        self.fmt_keys = fmt_keys if fmt_keys is not None else {}

    @override
    def format(self, record: logging.LogRecord) -> str:
        message = self._prepare_log_dict(record)
        return json.dumps(message, default=str)

    def _prepare_log_dict(self, record: logging.LogRecord):
        always_fields = {
            "message": record.getMessage(),
            "timestamp": dt.datetime.fromtimestamp(record.created, tz=dt.UTC).isoformat(),
        }
        if record.exc_info is not None:
            always_fields["exc_info"] = self.formatException(record.exc_info)

        if record.stack_info is not None:
            always_fields["stack_info"] = self.formatStack(record.stack_info)

        message = {
            key: msg_val if (msg_val := always_fields.pop(val, None)) is not None else getattr(record, val)
            for key, val in self.fmt_keys.items()
        }
        message.update(always_fields)

        for key, val in record.__dict__.items():
            if key not in LOG_RECORD_BUILTIN_ATTRS:
                message[key] = val

        return message


class WhiteListFilter(logging.Filter):
    """Filter that allows logging only from specified loggers.

    This filter checks if the log record's logger name is in the
    provided list of loggers. If it is, the log record is allowed
    to pass through; otherwise, it is filtered out.

    Args:
        loggers (list[str]): A list of logger names that are allowed
            to pass through the filter.

    Returns:
        bool: True if the log record should be logged, False otherwise.
    """

    def __init__(self, *, loggers: list[str]):
        self.loggers = [logging.Filter(name) for name in loggers]

    @override
    def filter(self, record: logging.LogRecord) -> bool | logging.LogRecord:
        return any(f.filter(record) for f in self.loggers)


class ColoredFormatter(logging.Formatter):
    """Custom formatter that adds color to log messages based on their level.

    This formatter enhances the visibility of log messages in the
    console by applying different colors to different log levels.

    Args:
        None

    Returns:
        str: The formatted log message with color codes.

    Raises:
        TypeError: If the log message and arguments cannot be formatted.
    """

    COLORS = {
        "DEBUG": "\033[94m",  # Blue
        "INFO": "\033[92m",  # Green
        "WARNING": "\033[93m",  # Yellow
        "ERROR": "\033[91m",  # Red
        "CRITICAL": "\033[95m",  # Magenta
        "RESET": "\033[0m",  # Reset to default color
    }

    @override
    def format(self, record: logging.LogRecord) -> str:
        levelname = record.levelname
        if levelname in self.COLORS:
            colored_levelname = f"{self.COLORS[levelname]}{levelname:8}{self.COLORS['RESET']}"
            record.colored_levelname = colored_levelname
        else:
            record.colored_levelname = levelname

        # Handle record.msg and record.args safely
        if record.args:
            try:
                record.msg = record.msg % record.args
                record.args = None
            except TypeError:
                pass

        return super().format(record)


def setup_logging(config_file_path: str) -> None:
    """Sets up logging and creates the logs directory if it doesn't exist.

    This directory is used to store log files generated by the application.
    Although it is not used directly in this file, it may be utilized by other
    components of the application to save logs.
    """
    os.makedirs(LOGS_DIR, exist_ok=True)
    config_file = pathlib.Path(config_file_path)
    with open(config_file) as file_in:
        config = json.load(file_in)
    logging.config.dictConfig(config)

    queue_handler = logging.getHandlerByName("queue_handler")
    if queue_handler and hasattr(queue_handler, "listener"):
        queue_handler.listener.start()
        atexit.register(queue_handler.listener.stop)
    elif queue_handler and hasattr(logging, "handlers") and hasattr(logging.handlers, "QueueListener"):
        if hasattr(queue_handler, "queue"):
            handlers = [h for h in logging.root.handlers if h != queue_handler]
            listener = logging.handlers.QueueListener(queue_handler.queue, *handlers)
            listener.start()
            atexit.register(listener.stop)
